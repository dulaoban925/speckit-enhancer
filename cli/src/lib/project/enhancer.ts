/**
 * Spec-Kit å¢å¼ºåŠŸèƒ½
 * å‚è€ƒ: specs/004-project-cli-commands/contracts/project-init.md
 */

import path from 'path';
import { execa } from 'execa';
import { fileExists, readProjectFile, atomicWriteFile } from '../fs.js';
import { DependencyError } from '../../types/project.js';

/**
 * æ£€æŸ¥ speckit CLI æ˜¯å¦å¯ç”¨
 */
export async function checkSpeckitAvailable(): Promise<boolean> {
  try {
    await execa('speckit', ['--version']);
    return true;
  } catch {
    return false;
  }
}

/**
 * å¢å¼º Claude å‘½ä»¤æ–‡ä»¶,æ”¯æŒè‡ªå®šä¹‰åˆ†æ”¯è§„åˆ™å‚æ•°
 * @param projectRoot é¡¹ç›®æ ¹ç›®å½•
 * @param branchPrefix å¯é€‰çš„é»˜è®¤åˆ†æ”¯å‰ç¼€
 */
export async function enhanceClaudeCommand(
  projectRoot: string,
  branchPrefix?: string
): Promise<boolean> {
  const commandPath = path.join(projectRoot, '.claude/commands/speckit.plan.md');

  if (!(await fileExists(commandPath))) {
    console.warn(`è­¦å‘Š: æœªæ‰¾åˆ° ${commandPath},è·³è¿‡å‘½ä»¤å¢å¼º`);
    return false;
  }

  try {
    const content = await readProjectFile(commandPath, projectRoot);

    // æ£€æŸ¥æ˜¯å¦å·²ç»å¢å¼ºè¿‡
    if (content.includes('## è‡ªå®šä¹‰åˆ†æ”¯è§„åˆ™')) {
      console.log('Claude å‘½ä»¤å·²ç»å¢å¼ºè¿‡,è·³è¿‡');
      return true;
    }

    // æ³¨å…¥å¢å¼ºå†…å®¹
    const enhancement = `

## è‡ªå®šä¹‰åˆ†æ”¯è§„åˆ™(å¯é€‰)

ç”¨æˆ·å¯ä»¥åœ¨æ‰§è¡Œ \`/speckit.plan\` æ—¶æŒ‡å®šè‡ªå®šä¹‰åˆ†æ”¯è§„åˆ™,æ ¼å¼å¦‚ä¸‹:

\`\`\`text
/speckit.plan åˆ†æ”¯å‰ç¼€ä¸º feature/
/speckit.plan åˆ†æ”¯å‘½åæ¨¡å¼ä¸º ^feat-[a-z0-9-]+$
\`\`\`

å½“æ£€æµ‹åˆ°è¿™äº›å‚æ•°æ—¶,åœ¨åˆ›å»ºåˆ†æ”¯æ—¶åº”ç”¨ç›¸åº”è§„åˆ™ã€‚

${branchPrefix ? `é»˜è®¤åˆ†æ”¯å‰ç¼€: \`${branchPrefix}\`\n` : ''}`;

    // åœ¨ ## Outline ä¹‹å‰æ³¨å…¥
    const enhancedContent = content.replace(/## Outline/, `${enhancement}\n## Outline`);

    await atomicWriteFile(commandPath, enhancedContent, projectRoot);
    console.log(`âœ… å·²ä¿®æ”¹ /speckit.plan å‘½ä»¤ä»¥æ”¯æŒè‡ªå®šä¹‰åˆ†æ”¯è§„åˆ™`);
    return true;
  } catch (error) {
    console.error(`å¢å¼º Claude å‘½ä»¤å¤±è´¥: ${error}`);
    return false;
  }
}

/**
 * åœ¨ CLAUDE.md ä¸­æ³¨å…¥å®ªç« çº¦æŸ
 * @param projectRoot é¡¹ç›®æ ¹ç›®å½•
 */
export async function injectConstitutionConstraints(projectRoot: string): Promise<boolean> {
  const claudeMdPath = path.join(projectRoot, 'CLAUDE.md');

  // æ£€æŸ¥å®ªç« æ–‡ä»¶æ˜¯å¦å­˜åœ¨
  const constitutionPaths = [
    path.join(projectRoot, '.specify/memory/constitution.md'),
    path.join(projectRoot, 'constitution.md'),
  ];

  let constitutionPath: string | undefined;
  for (const p of constitutionPaths) {
    if (await fileExists(p)) {
      constitutionPath = path.relative(projectRoot, p);
      break;
    }
  }

  if (!constitutionPath) {
    console.warn('è­¦å‘Š: æœªæ‰¾åˆ°å®ªç« æ–‡ä»¶,è·³è¿‡çº¦æŸæ³¨å…¥');
    return false;
  }

  // æ£€æŸ¥ CLAUDE.md æ˜¯å¦å­˜åœ¨
  if (!(await fileExists(claudeMdPath))) {
    console.warn(`è­¦å‘Š: æœªæ‰¾åˆ° ${claudeMdPath},è·³è¿‡çº¦æŸæ³¨å…¥`);
    return false;
  }

  try {
    const content = await readProjectFile(claudeMdPath, projectRoot);

    // æ£€æŸ¥æ˜¯å¦å·²ç»æ³¨å…¥è¿‡
    if (content.includes('## Constitution Constraints')) {
      console.log('CLAUDE.md å·²ç»æ³¨å…¥å®ªç« çº¦æŸ,è·³è¿‡');
      return true;
    }

    // æ„å»ºæ³¨å…¥å†…å®¹
    const injection = `

## Constitution Constraints

This project follows the Spec-Kit constitution defined in \`${constitutionPath}\`.
All code generated by Claude MUST comply with the principles and rules in the constitution.

Key principles:
- Follow the architectural patterns and technology constraints defined in the constitution
- Ensure all implementations align with the project's core values and quality standards
- Validate design decisions against constitution principles before implementation

Before making any architectural decisions, verify compliance with the constitution.
`;

    // åœ¨ ## Project Architecture ä¹‹å‰æ³¨å…¥,å¦‚æœæ‰¾ä¸åˆ°åˆ™åœ¨ ## Project Overview ä¹‹åæ³¨å…¥
    let enhancedContent: string;
    if (content.includes('## Project Architecture')) {
      enhancedContent = content.replace(/## Project Architecture/, `${injection}\n## Project Architecture`);
    } else if (content.includes('## Project Overview')) {
      enhancedContent = content.replace(
        /(## Project Overview[\s\S]*?)(\n## )/,
        `$1${injection}$2`
      );
    } else {
      // å¦‚æœä¸¤ä¸ªæ ‡é¢˜éƒ½ä¸å­˜åœ¨,è¿½åŠ åˆ°æ–‡ä»¶æœ«å°¾
      enhancedContent = content + injection;
    }

    await atomicWriteFile(claudeMdPath, enhancedContent, projectRoot);
    console.log(`âœ… å·²åœ¨ CLAUDE.md ä¸­æ³¨å…¥å®ªç« çº¦æŸ`);
    return true;
  } catch (error) {
    console.error(`æ³¨å…¥å®ªç« çº¦æŸå¤±è´¥: ${error}`);
    return false;
  }
}

/**
 * æ‰§è¡Œ speckit init
 * @param projectRoot é¡¹ç›®æ ¹ç›®å½•
 * @param verbose æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†è¾“å‡º
 */
export async function runSpeckitInit(projectRoot: string, verbose: boolean = false): Promise<void> {
  // æ£€æŸ¥ speckit æ˜¯å¦å¯ç”¨
  const isAvailable = await checkSpeckitAvailable();
  if (!isAvailable) {
    throw new DependencyError(
      'æœªæ‰¾åˆ° speckit CLI\nğŸ’¡ è¯·å…ˆå®‰è£… speckit CLI: npm install -g @speckit/cli'
    );
  }

  if (verbose) {
    console.log('â³ æ‰§è¡Œ speckit init...');
  }

  try {
    await execa('speckit', ['init'], {
      cwd: projectRoot,
      stdio: verbose ? 'inherit' : 'pipe',
    });

    if (verbose) {
      console.log('âœ… speckit init å®Œæˆ');
    }
  } catch (error: any) {
    throw new DependencyError(`speckit init æ‰§è¡Œå¤±è´¥: ${error.message}`);
  }
}

/**
 * æ£€æŸ¥é¡¹ç›®æ˜¯å¦å·²ç»åˆå§‹åŒ–
 */
export async function isProjectInitialized(projectRoot: string): Promise<boolean> {
  const specifyDir = path.join(projectRoot, '.specify');
  return fileExists(specifyDir);
}
